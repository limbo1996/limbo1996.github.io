---
layout: post
title: python数据结构与算法(队列)
tags: Python
editor_options: 
  markdown: 
    wrap: 72
---

> 参考慕课《数据结构与算法》

### 队列

队列也是一种有次序的数据集合，特征是

> 新数据项的添加总发生在一段， 而现存数据项的移除发生在另一端，
> 即**先进先出**

添加的一端称为"尾端"， 移除的一段称为"首端"。

队列只有一个入口一个出口，不允许从中间插入或移除数据。

#### 代码实现

``` {.python}
class Queue:
  def __init__(self):
    self.item = []
  def isEmpty(self):
    return self.items == []
  
  def enqueue(self, item):
    self.items.insert(0, item)
    
  def dequenue(self):
    return self.items.pop()
  def size(self):
    return len(self.items)
```

`enqueue`的复杂度为`O(n)`, `dequeue`的复杂度为`O(1)` 。

#### 队列的应用

##### 打印任务

模拟多人共享一台打印机，"先到先服务"。

![](https://gitee.com/limbo1996/picgo/raw/master/png/20210317220247.png)

###### 代码实现

首先确定生成概率：每小时会有十个学生提交20个作业，
也就是180秒会有一个作业生成并提交。

``` {.python}
'''
该问题需要考虑的因素
1. 打印任务的属性：提交时间， 打印页数
2，打印队列的属性：打印任务队列
3. 打印机的属性：打印速度，是否忙
'''
from Queue import Queue
import random

class Printer:
  def __init__(self, ppm):
    self.pagerate = ppm # 打印速度
    self.currentTask = None # 打印任务
    self.timeRemaining = 0 # 打印时间倒计时
    
  def tick(self): # 打印1秒
    if self.currentTask != None:
      self.timeRemaining = self.timeRemaining - 1
      if self.timeRemaining <= 0:
        self.currentTask = None
        
  def busy(self):
    if self.currentTask != None:
      return True
    else:
      return False
    
  def startNext(self, newtask): # 打印新作业
    self.currentTask = newtask
    self.timeRemaining = newtask.getPages() * 60/self.pagerate # 页数除打印速度
  
  
class Task:
  def __init__(self, time):
    self.timestamp = time # 生成时间戳
    self.pages = random.randrange(1, 21) # 打印页数
    
  def getStamp(self):
    return self.timestamp
  
  def getPages(self):
    return self.pages
  
  def waitTime(self, currenttime):
    return currenttime - self.timestamp #等待时间 
 
 
  
def newPrintTask(): # 1/ 180的概率生成一个作业
  num = random.randrange(1, 181)
  if num == 180:
    return True
  else:
    return False
  
  
  
  
  
def simulation(numSeconds, pagesPerMinute):# 模拟多长时间和打印机模式
  
  labprinter = Printer(pagesPerMinute)
  printQueue = Queue()
  waitingtimes = []
  
  for currentSecond in range(numSeconds):
    
    if newPrintTask():
      task = Task(currentSecond)
      printQueue.enqueue(task)
    
    if (not labprinter.busy()) and (not printQueue.isEmpty()):
      nexttask = printQueue.dequeue() # 从等待队列中移除进入打印
      waitingtimes.append(nexttask.waitTime(currentSecond)) # 计算等待时间
      
      labprinter.startNext(nexttask)
    
    labprinter.tick()
  
  averageWait = sum(waitingtimes) / len(waitingtimes)
  
  print("Average Wait %f secs %d tasks remaining." % (averageWait, printQueue.size()))
  

for i in range(10):
  simulation(3600, 5)

Average Wait 141.866667 secs 0 tasks remaining.
Average Wait 23.277778 secs 0 tasks remaining.
Average Wait 62.090909 secs 0 tasks remaining.
Average Wait 112.090909 secs 2 tasks remaining.
Average Wait 165.428571 secs 0 tasks remaining.
Average Wait 119.818182 secs 1 tasks remaining.
Average Wait 68.772727 secs 0 tasks remaining.
Average Wait 146.812500 secs 1 tasks remaining.
Average Wait 37.823529 secs 0 tasks remaining.
Average Wait 246.421053 secs 1 tasks remaining.
```
